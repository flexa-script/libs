// stack standard lib
// MIT License
// Copyright (c) 2024 Carlos Eduardo de Borba Machado

namespace flx;

using flx.std.collections.collection;

struct Stack {
	var collection: Collection;
}

fun len(stack: Stack): int;

fun create_stack(): Stack {
	return Stack{collection=create_collection()};
}

fun push(stack: Stack, value: any) {
	_default_append(stack.collection, ref value);
}

fun rstr2(str: string, count: int): string {
	var res = "";
	for (var i = 0; i < count; i++) {
		res += str;
	}
	return res;
}

fun pop(stack: Stack, level) {
	level++;
	println(rstr2("│ ", level), "├─", this.name, ": entered -> len(stack) -> ", len(stack));

	if (len(stack) == 0) {
		println(rstr2("##", level), "##", this.name, ": empty stack ERROR ----------------------------------------------------------------------");
	}

	try {
		_default_remove(stack.collection);
		println(rstr2("│ ", level), "└─", this.name, ": is returning");
	} catch (ex: Exception) {
		if (ex.error == "Tryed to remove from empty collection"){
			throw "Tryed to pop from empty stack";
		} else {
			throw ex;
		}
	}
}

fun peek(stack: Stack): any {
	// try {
		return ref _default_get(stack.collection);
	// } catch (ex: Exception) {
	// 	if (ex.error == "Tryed to get from empty collection"){
	// 		throw "Tryed to peek from empty stack";
	// 	} else {
	// 		throw ex;
	// 	}
	// }
}

fun clear(stack: Stack) {
	stack = create_stack();
}

fun len(stack: Stack): int {
	return stack.collection.size;
}

fun is_empty(stack: Stack): bool {
	return stack.collection.size == 0;
}

fun to_array(stack: Stack): any[] {
	return to_array(stack.collection);
}

fun copy(stack: Stack): Stack {
	return Stack{collection=copy(stack.collection)};
}
